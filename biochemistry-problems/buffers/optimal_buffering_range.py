#!/usr/bin/env python3

# built-in python modules
import os
import random
import argparse

# external pip modules

# local repo modules
import bptools
import bufferslib

#======================================
#======================================
def get_question_text(buffer_dict) -> str:
	"""
	Generates and returns the main text for the question.

	This function is responsible for creating the base question text.
	Currently, it returns a generic placeholder string, but in a real
	application, this could involve generating a dynamic question based
	on various inputs or parameters.

	Returns:
		str: A string containing the main question text.
	"""
	question_text = ""
	question_text += ('<p><strong>' + buffer_dict['acid_name'].capitalize()
		+ '</strong> and its conjugate base, ' + buffer_dict['base_name']
		+ ', ' + buffer_dict['description'] + '.</p> ')
	question_text += ('<p>' + buffer_dict['acid_name'].capitalize() + ' is ' + buffer_dict['protic_name']
		+ ' with '+bufferslib.pKa_list_to_words(buffer_dict['pKa_list'])+'.</p> ')
	question_text += "<p>Which one of the following pH values falls outside the optimal buffering range"
	question_text += f"of {buffer_dict['acid_name'].capitalize()}?</p>"
	return question_text

#======================================
#======================================
def pH_to_color_span(ph_value, use_gray=False):
	"""
	Convert a pH value to a colored HTML <span> element based on a gradient.

	- pH < 7: From dark red (1.0) to black or gray (7.0).
	- pH > 7: From black or gray (7.0) to dark blue (13.0).
	"""
	# Clamp the pH value between 1.0 and 13.0
	#ph_value = max(1.0, min(13.0, ph_value))

	min_color = 28  # Minimum value for r and b
	max_color = 128  # Maximum value for r and b
	g = min_color  # Green stays constant

	# Calculate RGB values
	if ph_value < 7.0:
		# Transition from red (128, 28, 28) to black/gray (28, 28, 28)
		b = min_color  # Blue stays at the minimum
		t = (ph_value - 1.0) / (7.0 - 1.0)  # Scale factor for interpolation
		r = int((max_color - min_color) * (1 - t) + min_color)  # Red decreases
	else:
		# Transition from black/gray (28, 28, 28) to blue (28, 28, 128)
		r = min_color  # Red stays at the minimum
		t = (ph_value - 7.0) / (13.0 - 7.0)  # Scale factor for interpolation
		b = int((max_color - min_color) * t + min_color)  # Blue increases

	# Convert RGB to hex color
	color_hex = f"#{r:02x}{g:02x}{b:02x}"

	# Return the HTML span element with the color
	return f'pH <span style="color: {color_hex}">{ph_value:.1f}</span>'


#======================================
#======================================
def random_float_not_near(number_list, lower_bound=2.0, upper_bound=12.0, min_distance=1.2, max_attempts=1000):
	for _ in range(max_attempts):
		# Generate a random float in the given range
		candidate = round(random.uniform(lower_bound, upper_bound),1)

		# Check if the candidate is far enough from all values in the list
		if all(abs(candidate - value) >= min_distance for value in number_list):
			return candidate

	raise ValueError(f"Could not find a suitable float after {max_attempts} attempts.")

#======================================
#======================================
def generate_choices(buffer_dict, num_choices: int) -> (list, str):
	"""
	Generates a list of answer choices along with the correct answer.

	Defines a fixed set of choices for multiple-choice questions.
	This function randomly selects a correct answer from a predefined
	list of correct choices, then adds a few incorrect choices from
	another list to fill out the choices list. The number of choices
	is constrained by `num_choices`.

	Args:
		num_choices (int): The total number of answer choices to generate.

	Returns:
		tuple: A tuple containing:
			- list: A list of answer choices (mixed correct and incorrect).
			- str: The correct answer text.
	"""
	# Define possible correct choices and incorrect choices
	#print(buffer_dict.keys())
	pka_list = buffer_dict['pKa_list']
	choices_list = []
	answer_value = random_float_not_near(pka_list)

	for pka in pka_list:
		choices_list.append(pka + random.random())
		choices_list.append(pka - random.random())
	random.shuffle(choices_list)
	choices_list = choices_list[:num_choices-1]
	choices_list.append(answer_value)
	choices_list.sort()
	choices_text_list = []
	for choice_value in choices_list:
		choice_text = pH_to_color_span(choice_value) #= f'{choice_value:.1f}'
		choices_text_list.append(choice_text)

	answer_text = pH_to_color_span(answer_value) #f'{answer_value:.1f}'

	return choices_text_list, answer_text

#======================================
#======================================
def write_question(N: int, buffer_dict: dict, num_choices: int) -> str:
	"""
	Creates a complete formatted question for output.

	This function combines the question text and choices generated by
	other functions into a formatted question string. The formatting
	is handled by a helper function from the `bptools` module.

	Args:
		N (int): The question number, used for labeling the question.
		num_choices (int): The number of answer choices to include.

	Returns:
		str: A formatted question string suitable for output, containing
		the question text, answer choices, and correct answer.
	"""
	# Generate the question text
	question_text = get_question_text(buffer_dict)

	# Generate answer choices and correct answer
	choices_list, answer_text = generate_choices(buffer_dict, num_choices)

	# Format the complete question with the specified module function
	complete_question = bptools.formatBB_MC_Question(N, question_text, choices_list, answer_text)
	return complete_question

#=====================
def parse_arguments():
	"""
	Parses command-line arguments for the script.

	Defines and handles all arguments for the script, including:
	- `duplicates`: The number of questions to generate.
	- `num_choices`: The number of answer choices for each question.
	- `question_type`: Type of question (numeric or multiple choice).

	Returns:
		argparse.Namespace: Parsed arguments with attributes `duplicates`,
		`num_choices`, and `question_type`.
	"""
	parser = argparse.ArgumentParser(description="Generate questions.")
	parser.add_argument(
		'-d', '--duplicates', metavar='#', type=int, dest='duplicates',
		help='Number of duplicate runs to do or number of questions to create', default=1
	)
	parser.add_argument(
		'-c', '--num_choices', type=int, default=5, dest='num_choices',
		help="Number of choices to create."
	)

	args = parser.parse_args()
	return args

#======================================
#======================================
def main():
	"""
	Main function that orchestrates question generation and file output.
	"""

	# Parse arguments from the command line
	args = parse_arguments()

	# Define output file name
	script_name = os.path.splitext(os.path.basename(__file__))[0]
	outfile = (
		'bbq'
		f'-{script_name}'
		'-questions.txt'
	)
	print(f'Writing to file: {outfile}')

	buffer_list = []
	buffer_list += list(bufferslib.triprotic.values())
	buffer_list += list(bufferslib.tetraprotic.values())

	# Open the output file and generate questions
	with open(outfile, 'w') as f:
		N = 1  # Question number counter
		for _ in range(args.duplicates):
			gene_letters_str = bptools.generate_gene_letters(3)
			buffer_dict = random.choice(buffer_list)
			buffer_dict = bufferslib.expand_buffer_dict(buffer_dict)
			complete_question = write_question(N, buffer_dict, args.num_choices)
			if complete_question is not None:
				N += 1
				f.write(complete_question)

	# Display histogram if question type is multiple choice
	bptools.print_histogram()

#======================================
#======================================
if __name__ == '__main__':
	main()

## THE END
