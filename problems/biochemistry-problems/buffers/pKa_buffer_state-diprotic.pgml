## TITLE('Biochemistry: Protonation state at a given pH (diprotic buffer)')
## DESCRIPTION
## Identify the most abundant protonation state of a diprotic buffer at a given pH using its pKa values and context.
## ENDDESCRIPTION
## KEYWORDS('buffers','pKa','protonation','pH','acid-base')
## DBsubject('Biochemistry')
## DBchapter('Chemistry of Water')
## DBsection('Buffers')
## Level(3)
## Date('2026-01-28')
## Author('Dr. Neil R. Voss')
## Institution('Roosevelt University')
## Language(en)
# https://github.com/vosslab
# This work is licensed under CC BY 4.0 (Creative Commons Attribution 4.0
# International License).
# https://creativecommons.org/licenses/by/4.0/
# Source code portions are licensed under LGPLv3.

DOCUMENT();

# ----------------------------
# 1) Preamble
# ----------------------------
loadMacros(
	'PGstandard.pl',
	'PGML.pl',
	'parserRadioButtons.pl',
	'PGcourse.pl',
);

$showPartialCorrectAnswers = 0;

# ----------------------------
# 2) Setup
# ----------------------------

# ----------------------------
# 2a) Helpers
# ----------------------------
my @STATE_COLORS = ('#00008B', '#404040', '#8B0000');

sub min_value {
	my $min = shift;
	for my $value (@_) {
		if ($value < $min) {
			$min = $value;
		}
	}
	return $min;
}

sub max_value {
	my $max = shift;
	for my $value (@_) {
		if ($value > $max) {
			$max = $value;
		}
	}
	return $max;
}

sub get_pH_values {
	my @pka_list = @_;
	my $min_pH_diff = 0.51;
	my $max_pH_diff = 1.9;
	my @all_pH_list = ();
	for (my $pH = 0.5; $pH <= 14.0; $pH += 0.5) {
		push @all_pH_list, sprintf('%.1f', $pH) + 0;
	}
	my @pH_list = ();
	for my $pH (@all_pH_list) {
		my $good_value = 1;
		for my $pKa (@pka_list) {
			if (abs($pKa - $pH) < $min_pH_diff) {
				$good_value = 0;
				last;
			}
		}
		if ($pH - max_value(@pka_list) > $max_pH_diff) {
			$good_value = 0;
		} elsif (min_value(@pka_list) - $pH > $max_pH_diff) {
			$good_value = 0;
		}
		if ($good_value) {
			push @pH_list, $pH;
		}
	}
	return @pH_list;
}

sub get_protonation_state {
	my ($pH_value, $pka_count, @values) = @_;
	my @pka_list = @values[0 .. ($pka_count - 1)];
	my @state_list = @values[$pka_count .. $#values];
	my $state = $state_list[-1];
	my $color = $STATE_COLORS[-1];
	for (my $i = 0; $i < scalar(@pka_list); $i++) {
		if ($pH_value < $pka_list[$i]) {
			$state = $state_list[$i];
			$color = $STATE_COLORS[$i];
			last;
		}
	}
	return ($state, $color);
}

sub format_chemical_formula_html {
	my ($chem_state, $color) = @_;
	my @string_list = split('', $chem_state);
	my $chem_form = '';
	my $charge;
	for my $character (@string_list) {
		if (defined($charge)) {
			if ($character eq '1') {
				$chem_form .= '<sup>' . $charge . '</sup>';
			} else {
				$chem_form .= '<sup>' . $character . $charge . '</sup>';
			}
		} elsif ($character eq '-' || $character eq '+') {
			$charge = $character;
		} elsif ($character =~ /[A-Za-z]/) {
			$chem_form .= $character;
		} elsif ($character =~ /[0-9]/) {
			$chem_form .= '<sub>' . $character . '</sub>';
		} else {
			$chem_form .= $character;
		}
	}
	if (defined($color)) {
		$chem_form = '<span style="color: ' . $color . '">' . $chem_form . '</span>';
	}
	return $chem_form;
}

sub format_list_of_chemical_formula_html {
	my @state_list = @_;
	my @formula_list = ();
	for (my $i = 0; $i < scalar(@state_list); $i++) {
		my $formula = format_chemical_formula_html($state_list[$i], $STATE_COLORS[$i]);
		push @formula_list, $formula;
	}
	return @formula_list;
}

sub random_choice {
	my ($rng, @items) = @_;
	my $item_count = scalar(@items);
	if ($item_count < 1) {
		die 'Random choice requires at least one item.';
	}
	my $index = $rng->random(0, $item_count - 1, 1);
	return $items[$index];
}

# ----------------------------
# 2b) Buffer data (diprotic)
# ----------------------------
my @buffers = (
	{
		acid_name => 'carbonic acid',
		base_name => 'carbonate',
		description => 'is also known as respiratory acid as it is the only acid excreted as a gas by the lungs',
		pka_list => [6.35, 10.33],
		state_list => ['H2CO3', 'HCO3-1', 'CO3-2'],
	},
	{
		acid_name => 'fumaric acid',
		base_name => 'fumarate',
		description => 'is produced by human skin when exposed to sunlight and is an intermediate in the citric acid cycle',
		pka_list => [3.03, 4.44],
		state_list => ['(COOH)CH=CH(COOH)', '(COOH)CH=CH(COO)-1', '(COO)CH=CH(COO)-2'],
	},
	{
		acid_name => 'malic acid',
		base_name => 'malate',
		description => 'is the main acid in many fruits and is an intermediate in the citric acid cycle',
		pka_list => [3.40, 5.20],
		state_list => ['(COOH)CH2CH(OH)COOH', '(COOH)CH2CH(OH)COO-1', '(COO)CH2CH(OH)COO-2'],
	},
	{
		acid_name => 'oxalic acid',
		base_name => 'oxalate',
		description => 'is found in many plants and vegetables and is a product of metabolic processes',
		pka_list => [1.27, 4.28],
		state_list => ['(COOH)2', '(HOOC)COO-1', '(COO)2-2'],
	},
	{
		acid_name => 'succinic acid',
		base_name => 'succinate',
		description => 'is an intermediate in the citric acid cycle and can act as a signaling molecule reflecting the cellular metabolic state',
		pka_list => [4.2, 5.6],
		state_list => ['(CH2)2(COOH)2', '(CH2)2(COOH)(COO)-1', '(CH2)2(COO)2-2'],
	},
	{
		acid_name => 'sulfurous acid',
		base_name => 'sulfite',
		description => 'occurs naturally in wine, but larger amounts are added to wine to stop fermentation and prevent spoilage',
		pka_list => [1.81, 6.97],
		state_list => ['H2SO3', 'HSO3-1', 'SO3-2'],
	},
	{
		acid_name => 'uric acid',
		base_name => 'urate',
		description => 'is an end product of nucleotide purine metabolism',
		pka_list => [5.4, 10.3],
		state_list => ['C5H4N4O3', 'C5H3N4O3-1', 'C5H2N4O3-2'],
	},
);

my $PROTIC_NAME = 'diprotic';
my $PKA_COUNT = 2;

# ----------------------------
# 2c) Randomization and choices
# ----------------------------
my $local_random = PGrandom->new();
$local_random->srand($problemSeed);

my $buffer = random_choice($local_random, @buffers);
my $acid_name = $buffer->{acid_name};
my $base_name = $buffer->{base_name};
my $description = $buffer->{description};
my @pka_list = @{ $buffer->{pka_list} };
my @state_list = @{ $buffer->{state_list} };
my $protic_name = $PROTIC_NAME;
my $pka_words = 'pK<sub>a</sub> values of <strong>' . sprintf('%.2f', $pka_list[0]) . '</strong> and <strong>'
	. sprintf('%.2f', $pka_list[1]) . '</strong>';
my @pH_list = get_pH_values(@pka_list);
my $pH_value = random_choice($local_random, @pH_list);

my @choices_list = format_list_of_chemical_formula_html(@state_list);
if ($local_random->random(0, 1, 0.0001) < 0.5) {
	@choices_list = reverse @choices_list;
}

my ($answer_state, $answer_color) = get_protonation_state($pH_value, $PKA_COUNT, @pka_list, @state_list);
my $answer_formula = format_chemical_formula_html($answer_state, $answer_color);

$question_text = '';
$question_text .= '<p><strong>' . ucfirst($acid_name) . '</strong> and its conjugate base, '
	. $base_name . ', ' . $description . '.</p> ';
$question_text .= '<p>' . ucfirst($acid_name) . ' is ' . $protic_name . ' with '
	. $pka_words . '.</p> ';
$question_text .= '<p>' . ucfirst($acid_name) . ' has ' . scalar(@state_list)
	. ' possible protonation states in the choices below.</p> ';
$question_text .= '<p>Which one of the following protonation states is the most abundant at <strong>pH '
	. sprintf('%.1f', $pH_value) . '</strong>?</p>';

$answer_plain = $answer_state;

$rb = RadioButtons(
	[@choices_list],
	$answer_formula,
	labels        => 'ABC',
	displayLabels => 1,
	randomize     => 0,
	separator     => '<div style="margin-bottom: 0.7em;"></div>',
);

# ----------------------------
# 3) Statement (PGML)
# ----------------------------
BEGIN_PGML
[$question_text]*

[_]{$rb}
END_PGML

# ----------------------------
# 3b) Hint
# ----------------------------
BEGIN_PGML_HINT
The protonation state of a molecule is determined by the relationship between the
solution's pH and the molecule's pKa. If the pH is lower than the pKa, the molecule
is mostly in its protonated form; if the pH is higher, it is mostly in its
deprotonated form.
END_PGML_HINT

# ----------------------------
# 4) Solution
# ----------------------------
BEGIN_PGML_SOLUTION
The correct answer is: [$answer_plain].
END_PGML_SOLUTION

ENDDOCUMENT();
