#!/usr/bin/env python3

# built-in python modules
import os
import random
import argparse

# external pip modules

# local repo modules
import bptools

def get_karyotype():
	chromosome_count = 46
	sex_chromosome_list = ['X'] + [random.choice(['X', 'Y'])]

	# Chromosome numbers for human (1-22 autosomes and sex chromosomes X, Y)
	chromosome_list = [str(i) for i in range(1, 23)] + ['X', 'Y']

	# Step 1: Choose aneuploid karyotype
	ploidy_change = random.choice(["+", "-"])  # One more or one less
	chromosome = random.choice(chromosome_list)  # Random chromosome choice

	# Ensure females cannot "lose" a Y chromosome
	if ploidy_change == "-" and chromosome == 'Y' and 'Y' not in sex_chromosome_list:
		chromosome = 'X'  # Switch to X if chromosome loss would be invalid

	# Update karyotype based on the ploidy change
	if ploidy_change == "+":
		chromosome_count += 1
		if chromosome in 'XY':
			sex_chromosome_list.append(chromosome)
			base_karyotype = f"{chromosome_count}"
		else:
			base_karyotype = f"{chromosome_count},{ploidy_change}{chromosome}"
	elif ploidy_change == "-":
		chromosome_count -= 1
		if chromosome in 'XY' and chromosome in sex_chromosome_list:
			sex_chromosome_list.remove(chromosome)
			base_karyotype = f"{chromosome_count}"
		else:
			base_karyotype = f"{chromosome_count},{ploidy_change}{chromosome}"

	# Sort and join sex chromosomes
	sex_chromosome_str = ''.join(sorted(sex_chromosome_list))
	full_karyotype = f'{base_karyotype},{sex_chromosome_str}'
	return full_karyotype

#======================================
#======================================
def get_question_text(karyotype) -> str:
	"""
	Generates and returns the main text for the question on aneuploidy.

	Args:
		karyotype (str): The generated karyotype notation.

	Returns:
		str: A string containing the main question text.
	"""
	question_text = f'In cytogenetic notation, what does "{karyotype}" refer to?'
	return question_text


#======================================
#======================================
def generate_choices(num_choices: int) -> (list, str):
	"""
	Generates a list of answer choices along with the correct answer.

	Defines a fixed set of choices for multiple-choice questions.
	This function randomly selects a correct answer from a predefined
	list of correct choices, then adds a few incorrect choices from
	another list to fill out the choices list. The number of choices
	is constrained by `num_choices`.

	Args:
		num_choices (int): The total number of answer choices to generate.

	Returns:
		tuple: A tuple containing:
			- list: A list of answer choices (mixed correct and incorrect).
			- str: The correct answer text.
	"""
	# Define possible correct choices and incorrect choices
	raise NotImplementedError
	choices_list = [
		'competitive inhibitor',
		'non-competitive inhibitor',
	]
	answer_text = random.choice(choices_list)
	wrong_choices_list = [
		'molecular stopper',
		'metabolic blocker',
	]
	random.shuffle(wrong_choices_list)
	choices_list.extend(wrong_choices_list[:num_choices - len(choices_list)])

	# Shuffle choices for random ordering
	random.shuffle(choices_list)

	return choices_list, answer_text

#======================================
#======================================
def write_question(N: int, num_choices: int) -> str:
	"""
	Creates a complete formatted question for output.

	This function combines the question text and choices generated by
	other functions into a formatted question string. The formatting
	is handled by a helper function from the `bptools` module.

	Args:
		N (int): The question number, used for labeling the question.
		num_choices (int): The number of answer choices to include.

	Returns:
		str: A formatted question string suitable for output, containing
		the question text, answer choices, and correct answer.
	"""
	karyotype = get_karyotype()
	question_text = get_question_text(karyotype)

	# Generate answer choices and correct answer
	choices_list, answer_text = generate_choices(num_choices)

	# Format the complete question with the specified module function
	complete_question = bptools.formatBB_MC_Question(N, question_text, choices_list, answer_text)
	return complete_question

#=====================
def parse_arguments():
	"""
	Parses command-line arguments for the script.

	Defines and handles all arguments for the script, including:
	- `duplicates`: The number of questions to generate.
	- `num_choices`: The number of answer choices for each question.
	- `question_type`: Type of question (numeric or multiple choice).

	Returns:
		argparse.Namespace: Parsed arguments with attributes `duplicates`,
		`num_choices`, and `question_type`.
	"""
	parser = argparse.ArgumentParser(description="Generate questions.")
	parser.add_argument(
		'-d', '--duplicates', metavar='#', type=int, dest='duplicates',
		help='Number of duplicate runs to do or number of questions to create', default=1
	)

	# Add an argument to specify the number of answer choices for each question
	parser.add_argument(
		'-c', '--num_choices', type=int, default=5, dest='num_choices',
		help="Number of choices to create."
	)

	args = parser.parse_args()
	return args

#======================================
#======================================
def main():
	"""
	Main function that orchestrates question generation and file output.

	This function uses parsed command-line arguments to control the number
	of questions to generate, the type of question (multiple choice or numeric),
	and the number of answer choices per question. It creates a formatted output
	file with all generated questions, and calls a helper function to display
	a histogram for multiple-choice questions.
	"""
	# Parse arguments from the command line
	args = parse_arguments()

	# Setup output file name
	outfile = f'bbq-{os.path.splitext(os.path.basename(__file__))[0]}-questions.txt'
	print(f'Writing to file: {outfile}')

	# Open the output file and generate questions
	with open(outfile, 'w') as f:
		N = 1  # Question number counter
		for _ in range(args.duplicates):
			complete_question = write_question(N, args.num_choices)
			if complete_question is not None:
				N += 1
				f.write(complete_question)

	# Display histogram if question type is multiple choice
	bptools.print_histogram()

#======================================
#======================================
if __name__ == '__main__':
	main()

## THE END
